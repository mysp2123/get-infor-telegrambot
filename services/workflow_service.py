"""
News-Facebook AI Agent Workflow Service
Orchestrates the complete workflow from news fetching to Facebook publishing

Workflow Steps:
1. Get & Rank News from 3 sources (Guardian, AP News, Reuters)
2. Present top 3 with inline buttons for user selection
3. Search Expert's Facebook for related posts
4. Generate Vietnamese content with AI
5. Create and approve image with PioneerX logo
6. Publish to Facebook and log all steps
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ContextTypes
import os
import random
from datetime import datetime, timedelta
from .enhanced_summary_service import EnhancedSummaryService
from .workflow_csv_logger import WorkflowCSVLogger
from .detailed_workflow_logger import DetailedWorkflowLogger

logger = logging.getLogger(__name__)

class WorkflowService:
    def __init__(self, news_service, ai_service, image_service, facebook_service, logging_service):
        self.news_service = news_service
        self.ai_service = ai_service
        self.image_service = image_service
        self.facebook_service = facebook_service
        self.logging_service = logging_service
        self.user_sessions = {}
        
        # Initialize Enhanced Summary Service v·ªõi Ultra RSS Power
        self.enhanced_summary_service = EnhancedSummaryService(ai_service)
        
        # Initialize Workflow CSV Logger
        self.csv_logger = WorkflowCSVLogger()
        
        # Initialize Detailed Workflow Logger (comprehensive tracking)
        self.detailed_logger = DetailedWorkflowLogger()
        
    async def start_workflow(self, user_id: int, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Start the complete News-Facebook AI Agent Workflow"""
        logger.info(f"üöÄ Starting News-Facebook AI Workflow for user {user_id}")
        
        # Log workflow start
        self.csv_logger.log_workflow_start(user_id)
        
        # Initialize user session
        self.user_sessions[user_id] = {
            'state': 'fetching_news',
            'start_time': datetime.now(),
            'articles': [],
            'selected_article': None,
            'expert_context': None,
            'generated_post': None,
            'generated_image': None,
            'facebook_post_id': None
        }
        
        # Send initial message
        progress_message = await context.bot.send_message(
            chat_id=chat_id,
            text="üöÄ **Kh·ªüi ƒë·ªông News-Facebook AI Agent Workflow**\n\n" +
                 "üì∞ ƒêang t√¨m ki·∫øm tin t·ª©c t·ª´ c√°c ngu·ªìn ch√≠nh...\n" +
                 "‚Ä¢ The Guardian\n‚Ä¢ AP News\n‚Ä¢ Reuters\n\n" +
                 "‚è≥ Vui l√≤ng ch·ªù...",
            parse_mode='Markdown'
        )
        
        try:
            # Step 1: Fetch and Rank News
            await self._step1_fetch_and_rank_news(user_id, context, chat_id, progress_message)
            
        except Exception as e:
            logger.error(f"‚ùå Workflow error for user {user_id}: {e}")
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"‚ùå **L·ªói trong qu√° tr√¨nh x·ª≠ l√Ω:**\n{str(e)}\n\n" +
                     "Vui l√≤ng th·ª≠ l·∫°i b·∫±ng c√°ch g·ª≠i **'Start'**",
                parse_mode='Markdown'
            )
    
    def get_user_session(self, user_id: int) -> Optional[Dict]:
        """Get user session data"""
        return self.user_sessions.get(user_id)
    
    def clear_user_session(self, user_id: int):
        """Clear user session data"""
        if user_id in self.user_sessions:
            del self.user_sessions[user_id]

    async def _step2_search_international_blogs(self, user_id: int, context: ContextTypes.DEFAULT_TYPE,
                                          chat_id: int, selected_article):
        """Step 2: Search International Blog Articles with RSS Sources"""
        
        logger.info(f"Starting international blog search for user {user_id}")
        
        try:
            # Search for related articles from international RSS sources
            logger.info(f"Searching international blogs for user {user_id}")
            blog_context = await self._search_international_blog_sources(selected_article)
            
            # Store in session
            self.user_sessions[user_id]['expert_context'] = blog_context
            self.user_sessions[user_id]['state'] = 'generating_post'
            logger.info(f"Updated session state to 'generating_post' for user {user_id}")
            
            # Send update about found articles
            found_articles = len(blog_context.get('related_articles', []))
            logger.info(f"Found {found_articles} international blog articles for user {user_id}")
            
            if found_articles > 0:
                context_message = f"‚úÖ **T√¨m th·∫•y {found_articles} b√†i vi·∫øt t·ª´ blog qu·ªëc t·∫ø**\n\n"
                
                # Show a preview of found articles with direct links
                for i, article in enumerate(blog_context['related_articles'][:5], 1):
                    title = article.get('title', 'Untitled')[:70]
                    source = article.get('source', 'Unknown Source')
                    url = article.get('url', '')
                    summary = article.get('summary', '')[:100]
                    credibility = article.get('credibility', 'N/A')
                    
                    context_message += f"üì∞ **{i}. {source}** ({credibility})\n"
                    context_message += f"üìÑ {title}...\n"
                    if summary:
                        context_message += f"üí° {summary}...\n"
                    context_message += f"üîó **Link:** {url}\n\n"
                
                # Show metadata
                metadata = blog_context.get('metadata', {})
                sources_list = metadata.get('sources', [])
                if sources_list:
                    context_message += f"üåê **Ngu·ªìn:** {', '.join(sources_list[:3])}...\n"
                    context_message += f"‚è±Ô∏è **Th·ªùi gian t√¨m ki·∫øm:** {metadata.get('processing_time', 'N/A')}\n\n"
                
                context_message += "ü§ñ **B∆∞·ªõc 3: T·∫°o n·ªôi dung AI v·ªõi ng·ªØ c·∫£nh qu·ªëc t·∫ø...**"
            else:
                context_message = "‚ÑπÔ∏è **Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt li√™n quan t·ª´ blog qu·ªëc t·∫ø**\n\n" + \
                                "ü§ñ **B∆∞·ªõc 3: T·∫°o n·ªôi dung AI kh√¥ng c√≥ ng·ªØ c·∫£nh b·ªï sung...**"
            
            logger.info(f"Sending blog context message to user {user_id}")
            try:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=context_message,
                    parse_mode='Markdown',
                    disable_web_page_preview=True
                )
            except Exception as parse_error:
                # Fallback without markdown if parsing fails
                safe_message = context_message.replace('**', '').replace('*', '')
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=safe_message,
                    disable_web_page_preview=True
                )
            
            # Continue to post generation
            logger.info(f"Continuing to step 3 for user {user_id}")
            await self._step3_generate_post(user_id, context, chat_id, selected_article, blog_context)
            
        except Exception as e:
            logger.error(f"‚ùå Error searching international blogs for user {user_id}: {e}")
            import traceback
            logger.error(f"Full traceback: {traceback.format_exc()}")
            
            try:
                # Continue without blog context
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="‚ö†Ô∏è **Kh√¥ng th·ªÉ t√¨m ki·∫øm blog qu·ªëc t·∫ø**\n\n" +
                         "ü§ñ **Ti·∫øp t·ª•c t·∫°o n·ªôi dung AI...**",
                    parse_mode='Markdown'
                )
                
                self.user_sessions[user_id]['expert_context'] = {'related_articles': []}
                logger.info(f"Continuing to step 3 without blog context for user {user_id}")
                await self._step3_generate_post(user_id, context, chat_id, selected_article, {'related_articles': []})
            except Exception as fallback_error:
                logger.error(f"Error in fallback for user {user_id}: {fallback_error}")

    async def _search_international_blog_sources(self, selected_article) -> Dict:
        """Search international blog sources using RSS service"""
        
        try:
            logger.info(f"üîç Searching international RSS sources for: {selected_article.title}")
            
            # Use enhanced summary service to find related articles
            enhanced_result = await self.enhanced_summary_service.search_international_content(
                selected_article, max_results=10
            )
            
            # Format for compatibility
            blog_context = {
                'search_query': selected_article.title,
                'related_articles': enhanced_result,
                'sources_used': list(set([article.get('source', 'Unknown') for article in enhanced_result])),
                'metadata': {
                    'articles_found': len(enhanced_result),
                    'sources': list(set([article.get('source', 'Unknown') for article in enhanced_result])),
                    'processing_time': '2-5s',
                    'search_method': 'RSS Enhanced Search'
                }
            }
            
            logger.info(f"‚úÖ Found {len(enhanced_result)} articles from international sources")
            return blog_context
            
        except Exception as e:
            logger.error(f"‚ùå Error searching international blog sources: {e}")
            return {
                'search_query': selected_article.title if selected_article else 'Unknown',
                'related_articles': [],
                'sources_used': [],
                'metadata': {'status': 'error', 'articles_found': 0}
            }

    def _extract_keywords_from_article(self, article) -> List[str]:
        """Extract relevant keywords from article for Facebook search"""
        import re
        from config import Config
        config = Config()
        
        # Combine title and content
        text = f"{article.title} {article.content}"
        
        # Extract keywords that match our relevance criteria
        keywords = []
        for keyword in config.RELEVANCE_KEYWORDS:
            if keyword.lower() in text.lower():
                keywords.append(keyword)
        
        # Add article-specific keywords
        words = re.findall(r'\b[A-Za-z]{4,}\b', text)
        important_words = [w for w in words if len(w) > 5 and w[0].isupper()][:5]
        keywords.extend(important_words)
        
        return list(set(keywords))[:10]  # Return unique keywords, max 10

    async def handle_post_approval(self, user_id: int, action: str, context: ContextTypes.DEFAULT_TYPE, query):
        """Handle post approval or edit request"""
        
        if user_id not in self.user_sessions:
            await query.answer("‚ùå Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n")
            return
        
        session = self.user_sessions[user_id]
        
        if action == 'approve':
            await query.answer("‚úÖ ƒê√£ ph√™ duy·ªát n·ªôi dung")
            session['state'] = 'generating_image'
            
            # Update message
            await query.edit_message_text(
                f"‚úÖ **N·ªôi dung ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát**\n\n" +
                f"{session['generated_post']}\n\n" +
                "üé® **B∆∞·ªõc 4: T·∫°o h√¨nh ·∫£nh v·ªõi logo PioneerX...**",
                parse_mode='Markdown'
            )
            
            # Continue to image generation
            await self._step4_generate_image(user_id, context, query.message.chat_id)
            
        elif action == 'edit':
            await query.answer("‚úèÔ∏è Vui l√≤ng g·ª≠i y√™u c·∫ßu ch·ªânh s·ª≠a")
            session['state'] = 'editing_post'
            
            await query.edit_message_text(
                f"‚úèÔ∏è **Ch·∫ø ƒë·ªô ch·ªânh s·ª≠a**\n\n" +
                f"N·ªôi dung hi·ªán t·∫°i:\n{session['generated_post']}\n\n" +
                "üí¨ **H√£y g·ª≠i tin nh·∫Øn ƒë·ªÉ ch·ªânh s·ª≠a:**\n" +
                "V√≠ d·ª•: 'L√†m ng·∫Øn g·ªçn h∆°n' ho·∫∑c 'Th√™m th√¥ng tin v·ªÅ t√°c ƒë·ªông kinh t·∫ø'",
                parse_mode='Markdown'
            )

    async def handle_post_edit_request(self, user_id: int, edit_request: str, 
                                     context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Handle post edit request from user"""
        
        if user_id not in self.user_sessions:
            await context.bot.send_message(chat_id, "‚ùå Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n")
            return
        
        session = self.user_sessions[user_id]
        
        if session['state'] != 'editing_post':
            await context.bot.send_message(chat_id, "‚ùå Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá")
            return
        
        try:
            # Create edit prompt
            edit_prompt = f"""
H√£y ch·ªânh s·ª≠a b√†i Facebook post sau theo y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng:

N·ªòI DUNG HI·ªÜN T·∫†I:
{session['generated_post']}

Y√äU C·∫¶U CH·ªàNH S·ª¨A:
{edit_request}

H√£y t·∫°o l·∫°i n·ªôi dung v·ªõi nh·ªØng thay ƒë·ªïi ƒë∆∞·ª£c y√™u c·∫ßu, gi·ªØ nguy√™n phong c√°ch v√† ƒë·ªô d√†i ph√π h·ª£p.
"""
            
            # Generate revised content
            revised_content = await self.ai_service.generate_content(edit_prompt)
            
            # Update session
            session['generated_post'] = revised_content
            session['state'] = 'approving_post'
            
            # Present revised content for approval
            progress_message = await context.bot.send_message(
                chat_id=chat_id,
                text="üîÑ ƒêang ch·ªânh s·ª≠a...",
                parse_mode='Markdown'
            )
            
            await self._present_post_approval(user_id, context, chat_id, revised_content, progress_message)
            
        except Exception as e:
            logger.error(f"‚ùå Error handling edit request: {e}")
            await context.bot.send_message(
                chat_id,
                f"‚ùå **L·ªói ch·ªânh s·ª≠a:**\n{str(e)}\n\nVui l√≤ng th·ª≠ l·∫°i.",
                parse_mode='Markdown'
            )

    async def handle_image_approval(self, user_id: int, action: str, context: ContextTypes.DEFAULT_TYPE, query):
        """Handle image approval or regeneration request"""
        
        if user_id not in self.user_sessions:
            await query.answer("‚ùå Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n")
            return
        
        session = self.user_sessions[user_id]
        
        if action == 'approve':
            await query.answer("‚úÖ ƒê√£ ph√™ duy·ªát h√¨nh ·∫£nh")
            session['state'] = 'publishing'
            
            # Update message
            await query.edit_message_text(
                "‚úÖ **H√¨nh ·∫£nh ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát**\n\n" +
                "üì± **B∆∞·ªõc 5: ƒêƒÉng l√™n Facebook...**",
                parse_mode='Markdown'
            )
            
            # Continue to publishing
            await self._step5_publish_to_facebook(user_id, context, query.message.chat_id)
            
        elif action == 'regenerate':
            await query.answer("üîÑ ƒêang t·∫°o ·∫£nh m·ªõi...")
            
            await query.edit_message_text(
                "üîÑ **ƒêang t·∫°o l·∫°i h√¨nh ·∫£nh...**\n‚è≥ Vui l√≤ng ch·ªù...",
                parse_mode='Markdown'
            )
            
            # Regenerate image
            await self._step4_generate_image(user_id, context, query.message.chat_id)

    async def _step1_fetch_and_rank_news(self, user_id: int, context: ContextTypes.DEFAULT_TYPE, 
                                        chat_id: int, progress_message):
        """Step 1: Fetch & Rank News from 3 sources"""
        
        # Update progress
        await progress_message.edit_text(
            "üì∞ **B∆∞·ªõc 1: Thu th·∫≠p & Ph√¢n t√≠ch tin t·ª©c**\n\n" +
            "üîç ƒêang t√¨m ki·∫øm b√†i vi·∫øt m·ªõi nh·∫•t...\n" +
            "‚è≥ Vui l√≤ng ch·ªù (30-60 gi√¢y)",
            parse_mode='Markdown'
        )
        
        # Fetch articles from all sources
        start_time = datetime.now()
        articles = await self.news_service.fetch_all_news()
        duration_ms = int((datetime.now() - start_time).total_seconds() * 1000)
        
        # Log news fetch
        self.csv_logger.log_step1_fetch_news(
            user_id=user_id,
            article_count=len(articles) if articles else 0,
            sources=['news_service', 'guardian', 'ap_news', 'reuters'],
            duration_ms=duration_ms,
            status='success' if articles else 'no_articles'
        )
        
        if not articles:
            await progress_message.edit_text(
                "‚ùå **Kh√¥ng th·ªÉ t√¨m th·∫•y tin t·ª©c**\n\n" +
                "C√≥ l·ªói khi k·∫øt n·ªëi v·ªõi c√°c ngu·ªìn tin. Vui l√≤ng th·ª≠ l·∫°i sau.",
                parse_mode='Markdown'
            )
            return
        
        # Remove duplicates and rank
        unique_articles = self.news_service.remove_duplicates(articles)
        ranked_articles = self.news_service.rank_articles(unique_articles)
        
        # Take top 3
        top_articles = ranked_articles[:3]
        
        # Store in session
        self.user_sessions[user_id]['articles'] = top_articles
        self.user_sessions[user_id]['state'] = 'selecting_article'
        
        # Present top 3 articles with inline buttons
        await self._present_article_selection(user_id, context, chat_id, top_articles, progress_message)

    def _escape_markdown(self, text: str) -> str:
        """Escape markdown special characters to prevent parsing errors"""
        if not text:
            return ""
        
        # Escape markdown special characters
        special_chars = ['*', '_', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
        escaped_text = text
        for char in special_chars:
            escaped_text = escaped_text.replace(char, f'\\{char}')
        return escaped_text

    async def _present_article_selection(self, user_id: int, context: ContextTypes.DEFAULT_TYPE,
                                       chat_id: int, articles: List, progress_message):
        """Present top 3 articles with formatted summaries and selection buttons"""
        
        try:
            # Build message with top 3 articles formatted properly
            message_text = "üèÜ **TOP 3 TIN T·ª®C ƒê∆Ø·ª¢C ƒê·ªÄ XU·∫§T**\n\n"
            
            for i, article in enumerate(articles, 1):
                relevance_score = getattr(article, 'relevance_score', 0)
                appeal_score = getattr(article, 'appeal_score', 0)
                
                # Format v·ªõi emoji ranking
                rank_emoji = ["ü•á", "ü•à", "ü•â"][i-1]
                
                # Escape markdown characters in title to prevent parsing errors
                safe_title = self._escape_markdown(article.title)
                safe_source = self._escape_markdown(article.source)
                safe_url = self._escape_markdown(article.url)
                
                message_text += f"{rank_emoji} **{i}\\. {safe_title}**\n"
                
                # Format t√≥m t·∫Øt theo y√™u c·∫ßu v·ªõi bullet points
                content_summary = self._format_article_summary(article.content)
                message_text += f"üìù **T√≥m t·∫Øt:**\n{content_summary}\n"
                
                message_text += f"üéØ ƒê·ªô li√™n quan: {relevance_score:.1f}/10\n"
                message_text += f"üî• ƒê·ªô h·∫•p d·∫´n: {appeal_score:.1f}/10\n"
                message_text += f"üîó Ngu·ªìn: {safe_source}\n"
                message_text += f"üìÑ ƒê·ªçc b√†i g·ªëc: {safe_url}\n\n"
            
            message_text += "üëá **Ch·ªçn b√†i vi·∫øt b·∫±ng n√∫t b·∫•m b√™n d∆∞·ªõi:**"
            
            # Update message with article selection
            await progress_message.edit_text(
                message_text,
                parse_mode='Markdown',
                disable_web_page_preview=True
            )
            
        except Exception as e:
            logger.error(f"Error in _present_article_selection with markdown: {e}")
            # Fallback: Use safe text without markdown
            try:
                safe_message = f"üèÜ TOP 3 TIN T·ª®C ƒê∆Ø·ª¢C ƒê·ªÄ XU·∫§T\n\n"
                
                for i, article in enumerate(articles, 1):
                    relevance_score = getattr(article, 'relevance_score', 0)
                    appeal_score = getattr(article, 'appeal_score', 0)
                    rank_emoji = ["ü•á", "ü•à", "ü•â"][i-1]
                    
                    safe_message += f"{rank_emoji} {i}. {article.title}\n"
                    content_summary = self._format_article_summary(article.content)
                    safe_message += f"üìù T√≥m t·∫Øt:\n{content_summary}\n"
                    safe_message += f"üéØ ƒê·ªô li√™n quan: {relevance_score:.1f}/10\n"
                    safe_message += f"üî• ƒê·ªô h·∫•p d·∫´n: {appeal_score:.1f}/10\n"
                    safe_message += f"üîó Ngu·ªìn: {article.source}\n"
                    safe_message += f"üìÑ ƒê·ªçc b√†i g·ªëc: {article.url}\n\n"
                
                safe_message += "üëá Ch·ªçn b√†i vi·∫øt b·∫±ng n√∫t b·∫•m b√™n d∆∞·ªõi:"
                
                await progress_message.edit_text(
                    safe_message,
                    disable_web_page_preview=True
                )
                
            except Exception as fallback_error:
                logger.error(f"Fallback edit also failed: {fallback_error}")
                # Send new message as last resort
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="üèÜ ƒê√£ t√¨m th·∫•y 3 b√†i vi·∫øt ph√π h·ª£p. ƒêang hi·ªÉn th·ªã danh s√°ch..."
                )
        
        # Create reply keyboard for selection
        from telegram import KeyboardButton, ReplyKeyboardMarkup
        keyboard = [
            [KeyboardButton("1Ô∏è‚É£ Ch·ªçn b√†i 1")],
            [KeyboardButton("2Ô∏è‚É£ Ch·ªçn b√†i 2")],
            [KeyboardButton("3Ô∏è‚É£ Ch·ªçn b√†i 3")],
            [KeyboardButton("üîÑ B·∫Øt ƒë·∫ßu l·∫°i")]
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
        
        # Send reply keyboard as separate message
        await context.bot.send_message(
            chat_id=chat_id,
            text="üëÜ **Ch·ªçn b√†i vi·∫øt:**",
            reply_markup=reply_markup
        )

    def _format_article_summary(self, content: str) -> str:
        """Format article content as bullet points with deduplication"""
        if not content:
            return "* Kh√¥ng c√≥ n·ªôi dung t√≥m t·∫Øt"
        
        # Clean content first
        content = content.strip()
        
        # Split content into sentences using multiple delimiters
        import re
        sentences = re.split(r'[.!?]+', content)
        
        # Clean and filter sentences, remove duplicates
        clean_sentences = []
        seen_sentences = set()
        
        for sentence in sentences:
            sentence = sentence.strip()
            
            # Skip empty, too short, or duplicate sentences
            if (not sentence or 
                len(sentence) < 30 or  # Increased minimum length for better quality
                sentence.lower() in seen_sentences):
                continue
                
            # Add sentence to seen set to prevent duplicates
            seen_sentences.add(sentence.lower())
            
            # Clean up sentence
            if not sentence.endswith('.'):
                sentence += '.'
                
            clean_sentences.append(sentence)
        
        # Take first 3-4 most meaningful sentences
        key_points = clean_sentences[:4]
        
        # If we don't have enough content, provide fallback
        if not key_points:
            return "* ƒêang x·ª≠ l√Ω n·ªôi dung b√†i vi·∫øt..."
        
        # Format as bullet points with proper Vietnamese structure
        formatted_summary = ""
        for i, point in enumerate(key_points):
            # Ensure proper Vietnamese bullet format
            formatted_summary += f"* {point}\n"
        
        return formatted_summary.strip()

    async def handle_article_selection_text(self, user_id: int, message_text: str, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Handle article selection via text message"""
        try:
            # Check if user has active workflow
            if user_id not in self.user_sessions:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="‚ùå Kh√¥ng t√¨m th·∫•y workflow ƒëang ho·∫°t ƒë·ªông. Vui l√≤ng g·ª≠i 'Start' ƒë·ªÉ b·∫Øt ƒë·∫ßu."
                )
                return
            
            # Parse selection - handle both keyboard buttons and manual text input
            selection_num = None
            
            if message_text == "1Ô∏è‚É£ Ch·ªçn b√†i 1":
                selection_num = 0
            elif message_text == "2Ô∏è‚É£ Ch·ªçn b√†i 2":
                selection_num = 1
            elif message_text == "3Ô∏è‚É£ Ch·ªçn b√†i 3":
                selection_num = 2
            elif message_text.startswith('B√†i '):
                try:
                    selection_num = int(message_text.split()[1]) - 1
                except ValueError:
                    selection_num = None
            elif message_text.isdigit():
                try:
                    selection_num = int(message_text) - 1
                except ValueError:
                    selection_num = None
            
            if selection_num is not None and 0 <= selection_num < len(self.user_sessions[user_id]['articles']):
                selected_article = self.user_sessions[user_id]['articles'][selection_num]
                
                # Log article selection
                self.csv_logger.log_step2_article_selection(
                    user_id=user_id,
                    selected_rank=selection_num + 1,
                    article_title=selected_article.title,
                    total_articles=len(self.user_sessions[user_id]['articles'])
                )
                
                # Hide keyboard first
                from telegram import ReplyKeyboardRemove
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚úÖ ƒê√£ ch·ªçn b√†i vi·∫øt s·ªë {selection_num + 1}",
                    reply_markup=ReplyKeyboardRemove()
                )
                
                # Show article details and scoring
                await self._show_article_details(user_id, context, chat_id, selected_article)
                
                # Move to writing style selection
                await self._step2_5_select_writing_style(user_id, context, chat_id, selected_article)
                return
            
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå Vui l√≤ng ch·ªçn b√†i vi·∫øt b·∫±ng c√°ch nh·∫•n n√∫t ho·∫∑c g·ª≠i 'B√†i 1', 'B√†i 2', 'B√†i 3'"
            )
            
        except Exception as e:
            logger.error(f"Error in handle_article_selection_text: {str(e)}")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå L·ªói x·ª≠ l√Ω l·ª±a ch·ªçn b√†i vi·∫øt. Vui l√≤ng th·ª≠ l·∫°i."
            )

    async def _show_article_details(self, user_id: int, context: ContextTypes.DEFAULT_TYPE, chat_id: int, article):
        """Show detailed article information and scoring"""
        try:
            # Get score breakdown
            score_breakdown = getattr(article, 'score_breakdown', {})
            relevance_score = getattr(article, 'relevance_score', 0)
            appeal_score = getattr(article, 'appeal_score', 0)
            final_score = getattr(article, 'final_score', 0)
            
            details_text = f"""üìä CHI TI·∫æT B√ÄI VI·∫æT ƒê√É CH·ªåN

üì∞ Ti√™u ƒë·ªÅ: {article.title}
üè¢ Ngu·ªìn: {article.source}
üìù N·ªôi dung: {article.content[:200]}...

üéØ ƒêI·ªÇM ƒê√ÅNH GI√Å:
‚Ä¢ ƒêi·ªÉm li√™n quan: {relevance_score:.1f}/10.0
‚Ä¢ ƒêi·ªÉm h·∫•p d·∫´n: {appeal_score:.1f}/10.0
‚Ä¢ ƒêi·ªÉm t·ªïng: {final_score:.1f}/10.0

üìà CHI TI·∫æT CH·∫§M ƒêI·ªÇM:
"""
            
            # Add relevance breakdown
            if hasattr(article, 'relevance_breakdown'):
                details_text += "\nüîç Ti√™u ch√≠ li√™n quan:\n"
                for criteria, score in article.relevance_breakdown.items():
                    criteria_name = {
                        'primary_keywords': 'T·ª´ kh√≥a ch√≠nh',
                        'secondary_keywords': 'T·ª´ kh√≥a ph·ª•',
                        'geographic_relevance': 'Li√™n quan ƒë·ªãa l√Ω',
                        'economic_impact': 'T√°c ƒë·ªông kinh t·∫ø',
                        'timeliness': 'T√≠nh th·ªùi s·ª±'
                    }.get(criteria, criteria)
                    details_text += f"  ‚Ä¢ {criteria_name}: {score:.1f}\n"
            
            # Add appeal breakdown
            if hasattr(article, 'appeal_breakdown'):
                details_text += "\nüí´ Ti√™u ch√≠ h·∫•p d·∫´n:\n"
                for criteria, score in article.appeal_breakdown.items():
                    criteria_name = {
                        'headline_appeal': 'Ti√™u ƒë·ªÅ h·∫•p d·∫´n',
                        'content_quality': 'Ch·∫•t l∆∞·ª£ng n·ªôi dung',
                        'controversy_factor': 'Y·∫øu t·ªë tranh c√£i',
                        'source_credibility': 'Uy t√≠n ngu·ªìn',
                        'engagement_potential': 'Ti·ªÅm nƒÉng t∆∞∆°ng t√°c'
                    }.get(criteria, criteria)
                    details_text += f"  ‚Ä¢ {criteria_name}: {score:.1f}\n"
            
            await context.bot.send_message(
                chat_id=chat_id,
                text=details_text,
                parse_mode=None
            )
            
        except Exception as e:
            logger.error(f"Error showing article details: {str(e)}")

    async def _step2_5_select_writing_style(self, user_id: int, context: ContextTypes.DEFAULT_TYPE, chat_id: int, selected_article):
        """Let user select writing style"""
        try:
            # Clear any previous generated content to allow new generation
            session = self.user_sessions[user_id]
            keys_to_clear = ['generated_post', 'generated_image', 'facebook_post_id', 'writing_style', 'expert_context']
            for key in keys_to_clear:
                if key in session:
                    del session[key]
                    logger.info(f"Cleared {key} from session for user {user_id}")
            
            # Store selected article
            session['selected_article'] = selected_article
            session['step'] = 'writing_style_selection'
            session['state'] = 'writing_style_selection'
            
            logger.info(f"User {user_id} selecting writing style for new article. Session reset.")
            
            # Present writing style options
            await self._present_writing_style_options(user_id, context, chat_id)
            
        except Exception as e:
            logger.error(f"Error in _step2_5_select_writing_style: {str(e)}")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå L·ªói hi·ªÉn th·ªã t√πy ch·ªçn phong c√°ch vi·∫øt. Vui l√≤ng th·ª≠ l·∫°i."
            )

    async def _present_writing_style_options(self, user_id: int, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Present writing style options to user v·ªõi buttons"""
        try:
            style_text = """‚úçÔ∏è CH·ªåN PHONG C√ÅCH VI·∫æT

Vui l√≤ng ch·ªçn phong c√°ch vi·∫øt cho b√†i post Facebook:

üìù C√ÅC PHONG C√ÅCH C√ì S·∫¥N:
1Ô∏è‚É£ Phong c√°ch Chuy√™n gia - Ph√¢n t√≠ch chuy√™n s√¢u, d·ªØ li·ªáu c·ª• th·ªÉ
2Ô∏è‚É£ Phong c√°ch Th√¢n thi·ªán - G·∫ßn g≈©i, d·ªÖ hi·ªÉu, nhi·ªÅu emoji
3Ô∏è‚É£ Phong c√°ch Tin t·ª©c - Ng·∫Øn g·ªçn, s√∫c t√≠ch, th√¥ng tin ch√≠nh
4Ô∏è‚É£ Phong c√°ch Tranh lu·∫≠n - ƒê·∫∑t c√¢u h·ªèi, khuy·∫øn kh√≠ch th·∫£o lu·∫≠n
5Ô∏è‚É£ Phong c√°ch Gi√°o d·ª•c - Gi·∫£i th√≠ch chi ti·∫øt, v√≠ d·ª• minh h·ªça
6Ô∏è‚É£ Phong c√°ch Truy·ªÅn c·∫£m h·ª©ng - T√≠ch c·ª±c, ƒë·ªông vi√™n, t·∫ßm nh√¨n

üé® T√ôY CH·ªàNH RI√äNG:
7Ô∏è‚É£ T·ª± nh·∫≠p phong c√°ch - M√¥ t·∫£ phong c√°ch ri√™ng c·ªßa b·∫°n

G·ª≠i s·ªë th·ª© t·ª± (1-7) ho·∫∑c 'Phong c√°ch X' ƒë·ªÉ ch·ªçn:"""

            # Create reply keyboard
            from telegram import KeyboardButton, ReplyKeyboardMarkup
            keyboard = [
                [KeyboardButton("Phong c√°ch 1"), KeyboardButton("Phong c√°ch 2")],
                [KeyboardButton("Phong c√°ch 3"), KeyboardButton("Phong c√°ch 4")],
                [KeyboardButton("Phong c√°ch 5"), KeyboardButton("Phong c√°ch 6")],
                [KeyboardButton("T·ª± nh·∫≠p phong c√°ch"), KeyboardButton("Quay l·∫°i")]
            ]
            reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
            
            # First hide any existing keyboard
            from telegram import ReplyKeyboardRemove
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚å®Ô∏è ƒêang t·∫£i t√πy ch·ªçn phong c√°ch vi·∫øt...",
                reply_markup=ReplyKeyboardRemove()
            )
            
            # Then send new keyboard
            await context.bot.send_message(
                chat_id=chat_id,
                text=style_text,
                reply_markup=reply_markup,
                parse_mode=None
            )
            
        except Exception as e:
            logger.error(f"Error presenting writing style options: {str(e)}")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå L·ªói hi·ªÉn th·ªã t√πy ch·ªçn phong c√°ch vi·∫øt.",
                parse_mode=None
            )

    async def handle_writing_style_selection(self, user_id: int, message_text: str, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Handle writing style selection"""
        try:
            if user_id not in self.user_sessions:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="‚ùå Kh√¥ng t√¨m th·∫•y workflow ƒëang ho·∫°t ƒë·ªông. Vui l√≤ng g·ª≠i 'Start' ƒë·ªÉ b·∫Øt ƒë·∫ßu."
                )
                return
            
            session = self.user_sessions[user_id]
            
            # Handle custom style input
            if message_text == "T·ª± nh·∫≠p phong c√°ch":
                session['step'] = 'custom_style_input'
                session['state'] = 'custom_style_input'
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="üé® Vui l√≤ng m√¥ t·∫£ phong c√°ch vi·∫øt m√† b·∫°n mu·ªën:\n\nV√≠ d·ª•: 'Vi·∫øt theo phong c√°ch h√†i h∆∞·ªõc, nhi·ªÅu meme, ph√π h·ª£p v·ªõi gen Z'"
                )
                return
            
            # Handle preset style selection
            style_mapping = {
                "Phong c√°ch 1": "expert",
                "Phong c√°ch 2": "friendly", 
                "Phong c√°ch 3": "news",
                "Phong c√°ch 4": "debate",
                "Phong c√°ch 5": "educational",
                "Phong c√°ch 6": "inspirational"
            }
            
            if message_text in style_mapping:
                selected_style = style_mapping[message_text]
                session['writing_style'] = self._get_style_config(selected_style)
                
                # Show selected style and continue
                style_name = self._get_style_name(selected_style)
                logger.info(f"User {user_id} selected style: {selected_style} ({style_name})")
                
                # Log writing style selection
                self.csv_logger.log_step4_writing_style(user_id, selected_style)
                
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚úÖ ƒê√£ ch·ªçn: {style_name}\n\n‚ñ∂Ô∏è Ti·∫øp t·ª•c ki·ªÉm tra Facebook chuy√™n gia..."
                )
                
                # Continue to international blog search - ensure user_id is int
                try:
                    uid = int(user_id) if isinstance(user_id, str) else user_id
                    await self._step2_search_international_blogs(uid, context, chat_id, session['selected_article'])
                except Exception as blog_error:
                    logger.error(f"Error in _step2_search_international_blogs for user {user_id}: {blog_error}")
                    # Continue without blog context
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text="‚ö†Ô∏è **Kh√¥ng th·ªÉ t√¨m ki·∫øm blog qu·ªëc t·∫ø**\n\nü§ñ **Ti·∫øp t·ª•c t·∫°o n·ªôi dung AI...**"
                    )
                    session['expert_context'] = {'related_articles': []}
                    await self._step3_generate_post(uid, context, chat_id, session['selected_article'], {'related_articles': []})
                return
            
            # Handle numeric input (1-7)
            try:
                style_num = int(message_text)
                if 1 <= style_num <= 6:
                    style_types = ["expert", "friendly", "news", "debate", "educational", "inspirational"]
                    selected_style = style_types[style_num - 1]
                    session['writing_style'] = self._get_style_config(selected_style)
                    
                    style_name = self._get_style_name(selected_style)
                    logger.info(f"User {user_id} selected numeric style {style_num}: {selected_style} ({style_name})")
                    
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=f"‚úÖ ƒê√£ ch·ªçn: {style_name}\n\n‚ñ∂Ô∏è Ti·∫øp t·ª•c t√¨m blog qu·ªëc t·∫ø li√™n quan..."
                    )
                    
                    # Continue to international blog search - ensure user_id is int
                    try:
                        uid = int(user_id) if isinstance(user_id, str) else user_id
                        await self._step2_search_international_blogs(uid, context, chat_id, session['selected_article'])
                    except Exception as blog_error:
                        logger.error(f"Error in _step2_search_international_blogs for user {user_id}: {blog_error}")
                        # Continue without blog context
                        await context.bot.send_message(
                            chat_id=chat_id,
                            text="‚ö†Ô∏è **Kh√¥ng th·ªÉ t√¨m ki·∫øm blog qu·ªëc t·∫ø**\n\nü§ñ **Ti·∫øp t·ª•c t·∫°o n·ªôi dung AI...**"
                        )
                        session['expert_context'] = {'related_articles': []}
                        await self._step3_generate_post(uid, context, chat_id, session['selected_article'], {'related_articles': []})
                    return
                elif style_num == 7:
                    session['step'] = 'custom_style_input'
                    session['state'] = 'custom_style_input'
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text="üé® Vui l√≤ng m√¥ t·∫£ phong c√°ch vi·∫øt m√† b·∫°n mu·ªën:\n\nV√≠ d·ª•: 'Vi·∫øt theo phong c√°ch h√†i h∆∞·ªõc, nhi·ªÅu meme, ph√π h·ª£p v·ªõi gen Z'"
                    )
                    return
            except ValueError:
                pass
            
            # Check if this is a post approval message that got misrouted
            if message_text in ["‚úÖ Ph√™ duy·ªát b√†i vi·∫øt", "‚úèÔ∏è Ch·ªânh s·ª≠a b√†i vi·∫øt"]:
                # User might be trying to approve post but state is wrong, try to fix
                if 'generated_post' in session:
                    session['state'] = 'approving_post'
                    session['step'] = 'approving_post'
                    
                    if message_text == "‚úÖ Ph√™ duy·ªát b√†i vi·∫øt":
                        await self.handle_post_approval_text(int(user_id), 'approve', context, chat_id)
                    elif message_text == "‚úèÔ∏è Ch·ªânh s·ª≠a b√†i vi·∫øt":
                        await self.handle_post_approval_text(int(user_id), 'edit', context, chat_id)
                    return
            
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn phong c√°ch t·ª´ 1-7 ho·∫∑c s·ª≠ d·ª•ng n√∫t b·∫•m.\n\n" +
                     "Ho·∫∑c g·ª≠i 'Start' ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i quy tr√¨nh."
            )
            
        except Exception as e:
            logger.error(f"Error in handle_writing_style_selection: {str(e)}")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå L·ªói x·ª≠ l√Ω l·ª±a ch·ªçn phong c√°ch vi·∫øt. Vui l√≤ng th·ª≠ l·∫°i.",
                parse_mode=None
            )

    async def handle_custom_style_input(self, user_id: int, message_text: str, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Handle custom writing style input"""
        try:
            if user_id not in self.user_sessions:
                return
            
            session = self.user_sessions[user_id]
            
            # Store custom style
            session['writing_style'] = {
                'type': 'custom',
                'description': message_text,
                'tone': 'custom',
                'structure': 'custom',
                'elements': ['custom_style']
            }
            
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"‚úÖ ƒê√£ l∆∞u phong c√°ch t√πy ch·ªânh:\n\n'{message_text}'\n\n‚ñ∂Ô∏è Ti·∫øp t·ª•c t√¨m blog qu·ªëc t·∫ø li√™n quan..."
            )
            
            # Continue to international blog search
            await self._step2_search_international_blogs(int(user_id), context, chat_id, session['selected_article'])
            
        except Exception as e:
            logger.error(f"Error in handle_custom_style_input: {str(e)}")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå L·ªói l∆∞u phong c√°ch t√πy ch·ªânh. Vui l√≤ng th·ª≠ l·∫°i."
            )

    def _get_style_config(self, style_type: str) -> Dict:
        """Get style configuration"""
        styles = {
            'expert': {
                'type': 'expert',
                'tone': 'professional',
                'structure': 'analysis',
                'elements': ['data', 'insights', 'recommendations', 'hashtags']
            },
            'friendly': {
                'type': 'friendly',
                'tone': 'casual',
                'structure': 'story',
                'elements': ['emojis', 'questions', 'personal_touch', 'hashtags']
            },
            'news': {
                'type': 'news',
                'tone': 'neutral',
                'structure': 'facts',
                'elements': ['key_facts', 'quotes', 'context', 'hashtags']
            },
            'debate': {
                'type': 'debate',
                'tone': 'provocative',
                'structure': 'argument',
                'elements': ['questions', 'contrasting_views', 'call_to_action', 'hashtags']
            },
            'educational': {
                'type': 'educational',
                'tone': 'informative',
                'structure': 'explanation',
                'elements': ['definitions', 'examples', 'step_by_step', 'hashtags']
            },
            'inspirational': {
                'type': 'inspirational',
                'tone': 'motivational',
                'structure': 'vision',
                'elements': ['positive_outlook', 'future_vision', 'encouragement', 'hashtags']
            }
        }
        return styles.get(style_type, styles['expert'])

    def _get_style_name(self, style_type: str) -> str:
        """Get style display name"""
        names = {
            'expert': 'Phong c√°ch Chuy√™n gia',
            'friendly': 'Phong c√°ch Th√¢n thi·ªán',
            'news': 'Phong c√°ch Tin t·ª©c',
            'debate': 'Phong c√°ch Tranh lu·∫≠n',
            'educational': 'Phong c√°ch Gi√°o d·ª•c',
            'inspirational': 'Phong c√°ch Truy·ªÅn c·∫£m h·ª©ng'
        }
        return names.get(style_type, 'Phong c√°ch Chuy√™n gia')

    async def _step3_generate_post(self, user_id: int, context: ContextTypes.DEFAULT_TYPE,
                                 chat_id: int, selected_article, expert_context: Dict):
        """Step 3: Generate Vietnamese Facebook Post with ULTRA SUMMARY POWER"""
        
        # Send progress update
        progress_message = await context.bot.send_message(
            chat_id=chat_id,
            text="üöÄ **B∆∞·ªõc 3: T·∫°o n·ªôi dung AI v·ªõi ULTRA RSS POWER**\n\n" +
                 "üìä ƒêang t·∫°o Enhanced Summary t·ª´ 10+ ngu·ªìn qu·ªëc t·∫ø...\n" +
                 "üåç Parallel RSS processing ƒëang ho·∫°t ƒë·ªông...\n" +
                 "‚è≥ Vui l√≤ng ch·ªù...",
            parse_mode='Markdown'
        )
        
        try:
            # STEP 3.1: Generate Ultra Enhanced Summary v·ªõi RSS Power
            logger.info(f"üöÄ Generating Ultra Enhanced Summary for user {user_id}")
            await progress_message.edit_text(
                "üöÄ **ULTRA RSS ENHANCED SUMMARY**\n\n" +
                "üìä ƒêang ph√¢n t√≠ch b√†i vi·∫øt v·ªõi AI...\n" +
                "üåê Searching 10+ international sources...\n" +
                "‚ö° Parallel processing activated...",
                parse_mode='Markdown'
            )
            
            enhanced_summary = await self.enhanced_summary_service.generate_enhanced_summary(selected_article)
            
            # Update with summary results
            articles_found = enhanced_summary.get('metadata', {}).get('articles_found', 0)
            await progress_message.edit_text(
                f"‚úÖ **ULTRA SUMMARY COMPLETED**\n\n" +
                f"üìä Articles found: {articles_found}\n" +
                f"üåç International analysis ready\n" +
                f"üáªüá≥ Domestic expert analysis ready\n\n" +
                f"üìù T·∫°o Facebook post ti·∫øng Vi·ªát...",
                parse_mode='Markdown'
            )
            
            # Store enhanced summary in session
            self.user_sessions[user_id]['enhanced_summary'] = enhanced_summary
            
            # STEP 3.2: Create Vietnamese content v·ªõi enhanced context
            session = self.user_sessions[user_id]
            logger.info(f"Creating Vietnamese content with enhanced summary for user {user_id}")
            prompt = self._create_enhanced_vietnamese_content_prompt(selected_article, expert_context, enhanced_summary, session)
            
            # Generate content with AI using enhanced prompt
            logger.info(f"Calling AI service to generate enhanced content for user {user_id}")
            start_time = datetime.now()
            ai_provider = "unknown"
            
            try:
                generated_content = await self.ai_service.generate_custom_content(prompt)
                ai_provider = "enhanced_ai_service"
                logger.info(f"Successfully generated enhanced content for user {user_id}, length: {len(generated_content)}")
            except Exception as ai_error:
                logger.error(f"AI service error for user {user_id}: {ai_error}")
                # Fallback to basic AI service method
                logger.info(f"Using fallback AI service method for user {user_id}")
                generated_content = await self.ai_service.generate_content(prompt)
                ai_provider = "basic_ai_service"
            
            # Calculate duration and log
            duration_ms = int((datetime.now() - start_time).total_seconds() * 1000)
            self.csv_logger.log_step5_content_generation(
                user_id=user_id,
                content_length=len(generated_content),
                ai_provider=ai_provider,
                duration_ms=duration_ms,
                status='success'
            )
            
            # Store in session
            self.user_sessions[user_id]['generated_post'] = generated_content
            self.user_sessions[user_id]['state'] = 'approving_post'
            
            logger.info(f"Presenting enhanced post approval for user {user_id}")
            # Present generated post for approval
            await self._present_enhanced_post_approval(user_id, context, chat_id, generated_content, enhanced_summary, progress_message)
            
        except Exception as e:
            logger.error(f"‚ùå Error generating enhanced post for user {user_id}: {e}")
            import traceback
            logger.error(f"Full traceback: {traceback.format_exc()}")
            
            try:
                await progress_message.edit_text(
                    f"‚ùå L·ªói t·∫°o enhanced content: {str(e)}\n\n" +
                    "‚ö†Ô∏è Fallback to basic mode...\n" +
                    "Vui l√≤ng th·ª≠ l·∫°i b·∫±ng c√°ch g·ª≠i 'Start'",
                    parse_mode='Markdown'
                )
            except Exception as edit_error:
                logger.error(f"Error editing progress message: {edit_error}")
                # Send new message if edit fails
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"‚ùå L·ªói t·∫°o enhanced content: {str(e)}\n\nVui l√≤ng th·ª≠ l·∫°i b·∫±ng c√°ch g·ª≠i 'Start'"
                )

    def _create_vietnamese_content_prompt(self, article, expert_context: Dict, session: Dict = None) -> str:
        """Create Vietnamese content generation prompt with expert context and style"""
        
        expert_posts = expert_context.get('related_posts', [])
        expert_context_text = ""
        
        if expert_posts:
            from config import Config
            config = Config()
            expert_context_text = f"\n\nNG·ªÆ C·∫¢NH T·ª™ CHUY√äN GIA {config.EXPERT_NAME}:\n"
            for i, post in enumerate(expert_posts[:2], 1):
                expert_context_text += f"B√†i {i}: {post.get('caption', '')[:200]}...\n"
                expert_context_text += f"Link: {post.get('url', '')}\n"
                expert_context_text += f"Engagement: {post.get('engagement', {}).get('likes', 0)} likes, {post.get('engagement', {}).get('comments', 0)} comments\n\n"
        
        # Get writing style from session
        writing_style = session.get('writing_style', {}) if session else {}
        style_instruction = self._generate_style_instruction(writing_style)
        
        prompt = f"""
B·∫°n l√† m·ªôt chuy√™n gia ph√¢n t√≠ch kinh t·∫ø v√† ch√≠nh tr·ªã qu·ªëc t·∫ø. H√£y vi·∫øt m·ªôt b√†i Facebook post b·∫±ng ti·∫øng Vi·ªát v·ªÅ tin t·ª©c sau:

TI√äU ƒê·ªÄ: {article.title}
N·ªòI DUNG: {article.content}
NGU·ªíN: {article.source}
{expert_context_text}

PHONG C√ÅCH VI·∫æT Y√äU C·∫¶U:
{style_instruction}

Y√äU C·∫¶U CHUNG:
- ƒê·ªô d√†i: 250-400 t·ª´
- S·ª≠ d·ª•ng ti·∫øng Vi·ªát t·ª± nhi√™n, ph√π h·ª£p v·ªõi ng∆∞·ªùi Vi·ªát
- Ph√¢n t√≠ch s√¢u s·∫Øc v·ªõi g√≥c nh√¨n Vi·ªát Nam
- K·∫øt th√∫c b·∫±ng c√¢u h·ªèi ƒë·ªÉ thu h√∫t t∆∞∆°ng t√°c ho·∫∑c hashtag li√™n quan
- Tr√°nh s·ª≠ d·ª•ng c√°c k√Ω t·ª± markdown nh∆∞ **, *, _, [], () trong n·ªôi dung
- T·∫°o n·ªôi dung s·∫µn s√†ng ƒëƒÉng tr·ª±c ti·∫øp l√™n Facebook

ƒê·ªäNH D·∫†NG OUTPUT:
- Ch·ªâ tr·∫£ v·ªÅ n·ªôi dung b√†i post ho√†n ch·ªânh
- Kh√¥ng bao g·ªìm ti√™u ƒë·ªÅ hay ph·∫ßn gi·∫£i th√≠ch th√™m
- ƒê·∫£m b·∫£o kh√¥ng c√≥ l·ªói ƒë·ªãnh d·∫°ng

H√£y t·∫°o n·ªôi dung h·∫•p d·∫´n v√† c√≥ gi√° tr·ªã cho ƒë·ªôc gi·∫£ Vi·ªát Nam:
"""
        
        return prompt
    
    def _generate_style_instruction(self, writing_style: Dict) -> str:
        """Generate style-specific instructions for AI"""
        if not writing_style:
            return "Phong c√°ch chuy√™n nghi·ªáp nh∆∞ng d·ªÖ hi·ªÉu, ph√π h·ª£p v·ªõi Facebook"
        
        style_type = writing_style.get('type', 'expert')
        
        if style_type == 'expert':
            return """
- Phong c√°ch chuy√™n gia: S·ª≠ d·ª•ng thu·∫≠t ng·ªØ chuy√™n m√¥n nh∆∞ng gi·∫£i th√≠ch r√µ r√†ng
- ƒê∆∞a ra ph√¢n t√≠ch chuy√™n s√¢u v·ªõi d·ªØ li·ªáu c·ª• th·ªÉ
- Cung c·∫•p khuy·∫øn ngh·ªã v√† nh·∫≠n ƒë·ªãnh c·ªßa chuy√™n gia
- S·ª≠ d·ª•ng bi·ªÉu ƒë·ªì emoji ƒë·ªÉ minh h·ªça d·ªØ li·ªáu (üìä üìà üìâ)
- C·∫•u tr√∫c: T√¨nh h√¨nh ‚Üí Ph√¢n t√≠ch ‚Üí T√°c ƒë·ªông ‚Üí Khuy·∫øn ngh·ªã
"""
        elif style_type == 'friendly':
            return """
- Phong c√°ch th√¢n thi·ªán: Vi·∫øt nh∆∞ n√≥i chuy·ªán v·ªõi b·∫°n b√®
- S·ª≠ d·ª•ng nhi·ªÅu emoji ƒë·ªÉ t·∫°o c·∫£m x√∫c (üòä ü§ó üí´ üåü)
- ƒê·∫∑t c√¢u h·ªèi ƒë·ªÉ khuy·∫øn kh√≠ch t∆∞∆°ng t√°c
- Chia s·∫ª g√≥c nh√¨n c√° nh√¢n, g·∫ßn g≈©i
- Tr√°nh thu·∫≠t ng·ªØ ph·ª©c t·∫°p, gi·∫£i th√≠ch ƒë∆°n gi·∫£n
- K·∫øt th√∫c v·ªõi l·ªùi m·ªùi th·∫£o lu·∫≠n
"""
        elif style_type == 'news':
            return """
- Phong c√°ch tin t·ª©c: Ng·∫Øn g·ªçn, s√∫c t√≠ch, ƒëi th·∫≥ng v√†o v·∫•n ƒë·ªÅ
- T·∫≠p trung v√†o 5W1H: Ai, C√°i g√¨, Khi n√†o, ·ªû ƒë√¢u, T·∫°i sao, Nh∆∞ th·∫ø n√†o
- Tr√¨nh b√†y theo th·ª© t·ª± quan tr·ªçng gi·∫£m d·∫ßn
- S·ª≠ d·ª•ng s·ªë li·ªáu v√† quote c·ª• th·ªÉ
- Emoji ch·ªâ d√πng ƒë·ªÉ nh·∫•n m·∫°nh ƒëi·ªÉm quan tr·ªçng (‚ö° üî• üì∞)
"""
        elif style_type == 'debate':
            return """
- Phong c√°ch tranh lu·∫≠n: ƒê·∫∑t ra c√¢u h·ªèi th√∫c ƒë·∫©y suy nghƒ©
- Tr√¨nh b√†y nhi·ªÅu g√≥c nh√¨n kh√°c nhau v·ªÅ v·∫•n ƒë·ªÅ
- S·ª≠ d·ª•ng c√¢u h·ªèi tu t·ª´ ƒë·ªÉ k√≠ch th√≠ch t∆∞ duy
- Khuy·∫øn kh√≠ch ng∆∞·ªùi ƒë·ªçc chia s·∫ª quan ƒëi·ªÉm
- K·∫øt th√∫c v·ªõi call-to-action r√µ r√†ng
- Emoji t·∫°o ƒë·ªông l·ª±c th·∫£o lu·∫≠n (ü§î üí≠ üó£Ô∏è üë•)
"""
        elif style_type == 'educational':
            return """
- Phong c√°ch gi√°o d·ª•c: Gi·∫£i th√≠ch chi ti·∫øt, d·ªÖ hi·ªÉu nh∆∞ gi·∫£ng b√†i
- Chia nh·ªè th√¥ng tin ph·ª©c t·∫°p th√†nh c√°c √Ω ƒë∆°n gi·∫£n
- S·ª≠ d·ª•ng v√≠ d·ª• minh h·ªça c·ª• th·ªÉ, g·∫ßn g≈©i
- C·∫•u tr√∫c r√µ r√†ng: ƒê·ªãnh nghƒ©a ‚Üí Gi·∫£i th√≠ch ‚Üí V√≠ d·ª• ‚Üí ·ª®ng d·ª•ng
- Emoji h·ªó tr·ª£ h·ªçc t·∫≠p (üìö üí° üéØ ‚úÖ)
- T·∫°o takeaway r√µ r√†ng cho ng∆∞·ªùi ƒë·ªçc
"""
        elif style_type == 'inspirational':
            return """
- Phong c√°ch truy·ªÅn c·∫£m h·ª©ng: T√≠ch c·ª±c, ƒë·ªông vi√™n, nh√¨n v·ªÅ t∆∞∆°ng lai
- T·∫≠p trung v√†o c∆° h·ªôi v√† kh·∫£ nƒÉng ph√°t tri·ªÉn
- S·ª≠ d·ª•ng ng√¥n ng·ªØ t√≠ch c·ª±c, ƒë·∫ßy hy v·ªçng
- Khuy·∫øn kh√≠ch h√†nh ƒë·ªông v√† thay ƒë·ªïi t√≠ch c·ª±c
- Emoji t·∫°o c·∫£m h·ª©ng (üöÄ üåü üí™ üéØ ‚≠ê)
- K·∫øt th√∫c v·ªõi th√¥ng ƒëi·ªáp motivational
"""
        elif style_type == 'custom':
            return f"""
- Phong c√°ch t√πy ch·ªânh: {writing_style.get('description', 'Phong c√°ch ƒë·∫∑c bi·ªát')}
- Th·ª±c hi·ªán theo y√™u c·∫ßu c·ª• th·ªÉ c·ªßa ng∆∞·ªùi d√πng
- Gi·ªØ t√≠nh chuy√™n nghi·ªáp trong n·ªôi dung kinh t·∫ø
- ƒê·∫£m b·∫£o ph√π h·ª£p v·ªõi n·ªÅn t·∫£ng Facebook
"""
        
        return "Phong c√°ch chuy√™n nghi·ªáp nh∆∞ng d·ªÖ hi·ªÉu, ph√π h·ª£p v·ªõi Facebook"

    def _create_enhanced_vietnamese_content_prompt(self, article, expert_context: Dict, enhanced_summary: Dict, session: Dict = None) -> str:
        """Create enhanced Vietnamese content generation prompt with Ultra Summary context"""
        
        # Extract enhanced summary components
        bullet_summary = enhanced_summary.get('bullet_summary', '')
        expert_analysis = enhanced_summary.get('expert_analysis', '')
        international_analysis = enhanced_summary.get('international_analysis', '')
        domestic_analysis = enhanced_summary.get('domestic_analysis', '')
        articles_found = enhanced_summary.get('metadata', {}).get('articles_found', 0)
        
        # Get writing style from session
        writing_style = session.get('writing_style', {}) if session else {}
        style_instruction = self._generate_style_instruction(writing_style)
        
        prompt = f"""
B·∫°n l√† m·ªôt chuy√™n gia ph√¢n t√≠ch kinh t·∫ø v√† ch√≠nh tr·ªã qu·ªëc t·∫ø v·ªõi access v√†o ULTRA RSS ENHANCED SUMMARY SYSTEM. 

B√ÄI VI·∫æT G·ªêC:
Ti√™u ƒë·ªÅ: {article.title}
N·ªôi dung: {article.content}
Ngu·ªìn: {article.source}

ULTRA ENHANCED SUMMARY ƒê√É T·∫†O (t·ª´ {articles_found} ngu·ªìn qu·ªëc t·∫ø):
üìù T√ìM T·∫ÆT:
{bullet_summary}

üáªüá≥ PH√ÇN T√çCH CHUY√äN GIA TRONG N∆Ø·ªöC:
{domestic_analysis}

üåç PH√ÇN T√çCH QU·ªêC T·∫æ:
{international_analysis}

PHONG C√ÅCH VI·∫æT Y√äU C·∫¶U:
{style_instruction}

Y√äU C·∫¶U:
- S·ª≠ d·ª•ng th√¥ng tin t·ª´ Ultra Enhanced Summary ƒë·ªÉ t·∫°o b√†i Facebook post ch·∫•t l∆∞·ª£ng cao
- K·∫øt h·ª£p g√≥c nh√¨n trong n∆∞·ªõc v√† qu·ªëc t·∫ø t·ª´ enhanced analysis
- ƒê·ªô d√†i: 250-400 t·ª´ (t·ªëi ∆∞u cho Facebook, s√∫c t√≠ch nh∆∞ng ƒë·∫ßy ƒë·ªß th√¥ng tin)
- S·ª≠ d·ª•ng ti·∫øng Vi·ªát t·ª± nhi√™n, chuy√™n nghi·ªáp
- Th·ªÉ hi·ªán depth analysis t·ª´ multiple international sources
- K·∫øt th√∫c b·∫±ng c√¢u h·ªèi ho·∫∑c call-to-action
- Tr√°nh markdown syntax trong output

ƒê·ªäNH D·∫†NG OUTPUT:
- Ch·ªâ tr·∫£ v·ªÅ n·ªôi dung Facebook post ho√†n ch·ªânh
- ƒê·∫£m b·∫£o n·ªôi dung ready-to-publish
- Kh√¥ng bao g·ªìm ti√™u ƒë·ªÅ hay ph·∫ßn gi·∫£i th√≠ch

H√£y t·∫°o b√†i post th·ªÉ hi·ªán s·ª©c m·∫°nh c·ªßa Ultra RSS Enhanced Analysis:
"""
        return prompt

    async def _present_enhanced_post_approval(self, user_id: int, context: ContextTypes.DEFAULT_TYPE,
                                   chat_id: int, generated_content: str, enhanced_summary: Dict, progress_message):
        """Present enhanced post v·ªõi Ultra Summary info - v·ªõi user approval options"""
        
        logger.info(f"Presenting enhanced post approval for user {user_id}")
        
        try:
            # Get summary stats
            articles_found = enhanced_summary.get('metadata', {}).get('articles_found', 0)
            sources = enhanced_summary.get('metadata', {}).get('sources', [])
            sources_text = ", ".join(sources[:3]) + ("..." if len(sources) > 3 else "")
            
            # Update message with generated content v√† summary info
            message_text = f"üöÄ **ULTRA ENHANCED CONTENT GENERATED**\n\n" + \
                          f"üìä **Powered by:** {articles_found} articles from {len(sources)} sources\n" + \
                          f"üåê **Sources:** {sources_text}\n\n" + \
                          f"üìù **CONTENT:**\n\n{generated_content}\n\n" + \
                          "‚ö° **Vui l√≤ng ch·ªçn h√†nh ƒë·ªông:**"
            
            logger.info(f"Editing progress message for enhanced post user {user_id}")
            await progress_message.edit_text(
                message_text,
                parse_mode='Markdown'
            )
            
            # Store generated content in session
            session = self.user_sessions[user_id]
            session['generated_post'] = generated_content
            session['enhanced_summary'] = enhanced_summary
            session['state'] = 'approving_content'
            session['step'] = 'content_approval'
            
            # Create keyboard with 2 options
            from telegram import ReplyKeyboardMarkup, KeyboardButton
            
            keyboard = [
                [KeyboardButton("‚úÖ Ch·∫•p nh·∫≠n n·ªôi dung")],
                [KeyboardButton("üîÑ T·∫°o b√†i vi·∫øt m·ªõi")]
            ]
            reply_markup = ReplyKeyboardMarkup(
                keyboard, 
                resize_keyboard=True, 
                one_time_keyboard=True
            )
            
            # Send approval options message with keyboard
            await context.bot.send_message(
                chat_id=chat_id,
                text="ü§î **B·∫°n c√≥ h√†i l√≤ng v·ªõi n·ªôi dung tr√™n kh√¥ng?**\n\n" +
                     "‚úÖ **Ch·∫•p nh·∫≠n n·ªôi dung:** Ti·∫øp t·ª•c t·∫°o h√¨nh ·∫£nh v√† ƒëƒÉng Facebook\n" +
                     "üîÑ **T·∫°o b√†i vi·∫øt m·ªõi:** T·∫°o l·∫°i n·ªôi dung v·ªõi phong c√°ch kh√°c",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            
        except Exception as e:
            logger.error(f"Error presenting enhanced post approval for user {user_id}: {e}")
            # Fallback: show simple text options
            session = self.user_sessions[user_id] 
            session['generated_post'] = generated_content
            session['state'] = 'approving_content'
            session['step'] = 'content_approval'
            
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ö° **N·ªôi dung ƒë√£ t·∫°o xong!**\n\n" +
                     "Vui l√≤ng g·ª≠i:\n" +
                     "‚úÖ 'Ch·∫•p nh·∫≠n' ƒë·ªÉ ti·∫øp t·ª•c\n" +
                     "üîÑ 'T·∫°o m·ªõi' ƒë·ªÉ t·∫°o l·∫°i n·ªôi dung",
                parse_mode='Markdown'
            )

    async def _step4_generate_image(self, user_id: int, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Step 4: Generate Image with PioneerX Logo"""
        
        # Send progress update
        progress_message = await context.bot.send_message(
            chat_id=chat_id,
            text="üé® **B∆∞·ªõc 4: T·∫°o h√¨nh ·∫£nh AI**\n\n" +
                 "üñºÔ∏è ƒêang t·∫°o ·∫£nh 16:9 v·ªõi logo PioneerX...\n" +
                 "‚è≥ Vui l√≤ng ch·ªù (30-60 gi√¢y)...",
            parse_mode='Markdown'
        )
        
        try:
            session = self.user_sessions[user_id]
            selected_article = session['selected_article']
            generated_content = session.get('generated_post', '')
            
            # Generate image using generated content context instead of original article
            if generated_content:
                # Use generated content as context for more relevant image
                image_context = {
                    'generated_content': generated_content,
                    'prompt_source': 'generated_content',
                    'style': 'facebook_post'
                }
                image_path = await self.image_service.generate_image(
                    title=selected_article.title,
                    content=generated_content,  # Use generated content instead of original
                    context=image_context
                )
            else:
                # Fallback to original article if no generated content
                image_path = await self.image_service.generate_image(
                    title=selected_article.title,
                    content=selected_article.content
                )
            
            if image_path and os.path.exists(image_path):
                # Log successful image generation
                self.csv_logger.log_step7_image_generation(
                    user_id=user_id,
                    image_path=image_path,
                    image_provider="advanced_image_service",
                    duration_ms=0,  # Duration tracked by image service internally
                    status='success'
                )
                
                session['generated_image'] = image_path
                session['state'] = 'approving_image'
                
                # Present image for approval
                await self._present_image_approval(user_id, context, chat_id, image_path, progress_message)
                
            else:
                await progress_message.edit_text(
                    "‚ùå L·ªói t·∫°o h√¨nh ·∫£nh\n\n" +
                    "Ti·∫øp t·ª•c ƒëƒÉng b√†i kh√¥ng c√≥ h√¨nh ·∫£nh...",
                    parse_mode=None
                )
                
                # Continue without image
                session['generated_image'] = None
                await self._step5_publish_to_facebook(user_id, context, chat_id)
                
        except Exception as e:
            logger.error(f"‚ùå Error generating image: {e}")
            
            await progress_message.edit_text(
                f"‚ùå L·ªói t·∫°o h√¨nh ·∫£nh:\n{str(e)}\n\n" +
                "Ti·∫øp t·ª•c ƒëƒÉng b√†i kh√¥ng c√≥ h√¨nh ·∫£nh...",
                parse_mode=None
            )
            
            # Continue without image
            session = self.user_sessions[user_id]
            session['generated_image'] = None
            await self._step5_publish_to_facebook(user_id, context, chat_id)

    def _create_image_prompt(self, article) -> str:
        """Create enhanced image generation prompt based on article content"""
        
        # Extract key themes from article
        title_lower = article.title.lower()
        content_lower = article.content.lower()
        combined_text = f"{title_lower} {content_lower}"
        
        # Analyze content for specific visual elements
        visual_elements = []
        color_schemes = []
        composition_elements = []
        
        # Determine primary theme and visual elements
        if any(word in combined_text for word in ['trump', 'election', 'politics', 'president', 'government']):
            visual_elements.extend([
                "political landscape", "American flag elements", "government buildings", 
                "presidential imagery", "political symbols"
            ])
            color_schemes.extend(["red white and blue", "patriotic colors", "official government colors"])
            
        if any(word in combined_text for word in ['economy', 'economic', 'market', 'business', 'trade', 'financial']):
            visual_elements.extend([
                "financial charts and graphs", "stock market imagery", "business icons",
                "economic indicators", "trading floor atmosphere", "corporate buildings"
            ])
            color_schemes.extend(["professional blue and gold", "financial green and red", "corporate colors"])
            
        if any(word in combined_text for word in ['tariff', 'tax', 'trade war', 'import', 'export']):
            visual_elements.extend([
                "international trade symbols", "shipping containers", "global trade routes",
                "cargo ships", "world map connections", "customs and border imagery"
            ])
            color_schemes.extend(["international blue", "trade route gold", "global connectivity colors"])
            
        if any(word in combined_text for word in ['china', 'chinese', 'asian', 'asia-pacific']):
            visual_elements.extend([
                "East Asian architectural elements", "modern Asian cityscape", 
                "China-US relations symbols", "Pacific region imagery"
            ])
            color_schemes.extend(["East Asian red and gold", "modern metropolitan colors"])
            
        if any(word in combined_text for word in ['vietnam', 'vietnamese', 'southeast asia', 'asean']):
            visual_elements.extend([
                "Southeast Asian elements", "Vietnamese flag colors", "ASEAN symbols",
                "tropical business environment", "emerging market imagery"
            ])
            color_schemes.extend(["Vietnamese red and yellow", "tropical business colors"])
            
        if any(word in combined_text for word in ['technology', 'ai', 'digital', 'tech', 'innovation']):
            visual_elements.extend([
                "high-tech graphics", "digital network patterns", "AI and technology symbols",
                "modern tech interfaces", "innovation imagery"
            ])
            color_schemes.extend(["tech blue and silver", "digital neon colors", "innovation purple"])
            
        # Geographic context
        geographic_elements = []
        if any(word in combined_text for word in ['global', 'international', 'worldwide', 'world']):
            geographic_elements.append("world map overlay")
            
        if any(word in combined_text for word in ['us', 'america', 'american', 'united states']):
            geographic_elements.append("American geographic elements")
            
        if any(word in combined_text for word in ['asia', 'asian', 'pacific']):
            geographic_elements.append("Asia-Pacific regional elements")
        
        # Determine urgency and tone
        urgency_indicators = []
        if any(word in combined_text for word in ['breaking', 'urgent', 'crisis', 'emergency']):
            urgency_indicators.append("urgent news alert style")
            color_schemes.append("alert red and orange")
            
        if any(word in combined_text for word in ['growth', 'positive', 'increase', 'boom']):
            urgency_indicators.append("positive growth indicators")
            color_schemes.append("growth green")
            
        if any(word in combined_text for word in ['decline', 'fall', 'crisis', 'negative']):
            urgency_indicators.append("caution and warning elements")
            color_schemes.append("warning amber and red")
        
        # Build comprehensive prompt
        base_elements = ["professional news media illustration", "high quality", "eye-catching composition"]
        
        # Select most relevant elements (avoid overcrowding)
        selected_visuals = visual_elements[:3] if visual_elements else ["modern business graphics"]
        selected_colors = color_schemes[:2] if color_schemes else ["professional blue and white"]
        selected_geography = geographic_elements[:1] if geographic_elements else []
        selected_urgency = urgency_indicators[:1] if urgency_indicators else []
        
        # Combine all elements
        all_elements = (base_elements + selected_visuals + selected_colors + 
                       selected_geography + selected_urgency)
        
        # Create final prompt
        prompt = f"{', '.join(all_elements)}, 16:9 aspect ratio, news media style, engaging visual design, suitable for Facebook post, professional presentation"
        
        # Add specific context if article has clear focus
        if 'trump' in title_lower and 'tariff' in combined_text:
            prompt += ", Trump policy announcement style, tariff impact visualization"
        elif 'market' in title_lower and any(word in combined_text for word in ['up', 'down', 'surge', 'drop']):
            prompt += ", stock market movement visualization, trading floor energy"
        elif 'vietnam' in combined_text and 'trade' in combined_text:
            prompt += ", Vietnam trade relationship focus, ASEAN economic cooperation"
        
        # Ensure clean, professional output
        prompt += ", clean layout, readable design, social media optimized"
        
        return prompt

    def _create_image_prompt_from_generated_content(self, generated_content: str, original_article) -> str:
        """Create image prompt based on generated Facebook content instead of original article"""
        
        # Extract key themes from generated content
        content_lower = generated_content.lower()
        title_lower = original_article.title.lower()
        
        # Analyze generated content for visual elements
        visual_elements = []
        color_schemes = []
        composition_elements = []
        
        # Look for specific topics mentioned in the generated content
        if any(word in content_lower for word in ['trump', 't·ªïng th·ªëng', 'ch√≠nh tr·ªã', 'b·∫ßu c·ª≠', 'ch√≠nh ph·ªß']):
            visual_elements.extend([
                "presidential imagery", "political symbols", "American flag elements",
                "government buildings", "official announcement style"
            ])
            color_schemes.extend(["patriotic red white blue", "official government colors"])
            
        if any(word in content_lower for word in ['kinh t·∫ø', 'th·ªã tr∆∞·ªùng', 'doanh nghi·ªáp', 't√†i ch√≠nh', 'thu·∫ø quan']):
            visual_elements.extend([
                "financial charts and graphs", "business growth indicators", 
                "economic symbols", "market trend visualization", "corporate imagery"
            ])
            color_schemes.extend(["professional blue and gold", "financial green", "business colors"])
            
        if any(word in content_lower for word in ['trung qu·ªëc', 'china', 'ch√¢u √°', 'th∆∞∆°ng m·∫°i qu·ªëc t·∫ø']):
            visual_elements.extend([
                "international trade symbols", "Asia-Pacific imagery", 
                "global connection graphics", "trade route visualization"
            ])
            color_schemes.extend(["international blue", "Asia-Pacific colors", "global trade gold"])
            
        if any(word in content_lower for word in ['vi·ªát nam', 'vietnamese', 'asean', 'ƒë√¥ng nam √°']):
            visual_elements.extend([
                "Southeast Asian business elements", "Vietnam flag colors",
                "ASEAN cooperation symbols", "emerging market imagery"
            ])
            color_schemes.extend(["Vietnamese red and yellow", "ASEAN blue", "emerging market colors"])
            
        if any(word in content_lower for word in ['c√¥ng ngh·ªá', 'ai', 'digital', 'innovation', 'tech']):
            visual_elements.extend([
                "high-tech graphics", "AI and technology symbols", 
                "digital innovation imagery", "modern tech interfaces"
            ])
            color_schemes.extend(["tech blue and silver", "innovation purple", "digital colors"])
        
        # Extract emotional tone from generated content
        emotional_elements = []
        if any(word in content_lower for word in ['t√≠ch c·ª±c', 'tƒÉng tr∆∞·ªüng', 'ph√°t tri·ªÉn', 'c∆° h·ªôi']):
            emotional_elements.append("positive growth energy")
            color_schemes.append("optimistic green and blue")
            
        if any(word in content_lower for word in ['th√°ch th·ª©c', 'kh√≥ khƒÉn', 'r·ªßi ro', 'c·∫£nh b√°o']):
            emotional_elements.append("caution and awareness tone")
            color_schemes.append("warning amber and orange")
            
        if any(word in content_lower for word in ['kh·ªßng ho·∫£ng', 'suy tho√°i', 'gi·∫£m', 'lo ng·∫°i']):
            emotional_elements.append("serious concern atmosphere")
            color_schemes.append("alert red and dark blue")
        
        # Build comprehensive prompt based on generated content
        base_elements = [
            "professional Facebook post illustration", "eye-catching social media design",
            "Vietnamese audience appeal", "news media style", "engaging visual"
        ]
        
        # Select most relevant elements
        selected_visuals = visual_elements[:3] if visual_elements else ["modern business graphics"]
        selected_colors = color_schemes[:2] if color_schemes else ["professional blue and white"]
        selected_emotional = emotional_elements[:1] if emotional_elements else ["neutral professional tone"]
        
        # Combine all elements
        all_elements = base_elements + selected_visuals + selected_colors + selected_emotional
        
        # Create final prompt optimized for Facebook post
        prompt = f"{', '.join(all_elements)}, 16:9 aspect ratio, Facebook post optimized, social media friendly, Vietnamese context, engaging for Vietnamese audience"
        
        # Add specific context based on generated content focus
        if 'trump' in content_lower and 'thu·∫ø quan' in content_lower:
            prompt += ", Trump tariff policy impact visualization, international trade focus"
        elif 'vi·ªát nam' in content_lower and 'xu·∫•t kh·∫©u' in content_lower:
            prompt += ", Vietnam export economy focus, Southeast Asian business context"
        elif 'th·ªã tr∆∞·ªùng' in content_lower and any(word in content_lower for word in ['tƒÉng', 'gi·∫£m']):
            prompt += ", market movement visualization, economic trend display"
        
        # Ensure social media optimization
        prompt += ", clean readable layout, social media optimized, attention-grabbing design"
        
        return prompt

    async def _present_image_approval(self, user_id: int, context: ContextTypes.DEFAULT_TYPE,
                                    chat_id: int, image_path: str, progress_message):
        """Present generated image for user approval"""
        
        # Send image
        await context.bot.send_photo(
            chat_id=chat_id,
            photo=open(image_path, 'rb'),
            caption="üé® H√¨nh ·∫£nh AI ƒë√£ t·∫°o v·ªõi logo PioneerX\n\nüëá Ch·ªçn h√†nh ƒë·ªông b·∫±ng n√∫t b·∫•m b√™n d∆∞·ªõi:",
            parse_mode=None
        )
        
        # Create approval keyboard
        keyboard = [
            [KeyboardButton("‚úÖ Ph√™ duy·ªát h√¨nh ·∫£nh")],
            [KeyboardButton("üîÑ T·∫°o l·∫°i h√¨nh ·∫£nh")],
            [KeyboardButton("üîÑ B·∫Øt ƒë·∫ßu l·∫°i")]
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
        
        # Send approval keyboard
        await context.bot.send_message(
            chat_id=chat_id,
            text="üëÜ **Ch·ªçn h√†nh ƒë·ªông:**",
            reply_markup=reply_markup
        )
        
        # Delete progress message
        try:
            await progress_message.delete()
        except:
            pass

    async def _step5_publish_to_facebook(self, user_id: int, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Step 5: Publish to Facebook and Log Results"""
        
        session = self.user_sessions[user_id]
        
        # Send progress update
        progress_message = await context.bot.send_message(
            chat_id=chat_id,
            text="üì± **B∆∞·ªõc 5: ƒêƒÉng l√™n Facebook**\n\n" +
                 "üöÄ ƒêang ƒëƒÉng b√†i l√™n Facebook page...\n" +
                 "‚è≥ Vui l√≤ng ch·ªù...",
            parse_mode='Markdown'
        )
        
        try:
            # Prepare content and image
            content = session['generated_post']
            image_path = session.get('generated_image')
            
            # Try Facebook API first
            result = await self.facebook_service.publish_post(content, image_path)
            
            if result.get('success'):
                post_id = result.get('post_id')
                post_url = result.get('post_url')
                
                session['facebook_post_id'] = post_id
                session['state'] = 'completed'
                
                # Log workflow completion
                total_duration_ms = int((datetime.now() - session['start_time']).total_seconds() * 1000)
                self.csv_logger.log_workflow_complete(
                    user_id=user_id,
                    total_duration_ms=total_duration_ms,
                    final_status='success'
                )
                
                # Send success message
                await progress_message.edit_text(
                    f"üéâ **Ho√†n th√†nh th√†nh c√¥ng!**\n\n" +
                    f"‚úÖ ƒê√£ ƒëƒÉng b√†i l√™n Facebook\n" +
                    f"üîó [Xem b√†i ƒëƒÉng]({post_url})\n" +
                    f"üìä Post ID: {post_id}\n\n" +
                    f"üìù **T√≥m t·∫Øt quy tr√¨nh:**\n" +
                    f"‚Ä¢ T√¨m th·∫•y {len(session['articles'])} tin t·ª©c\n" +
                    f"‚Ä¢ ƒê√£ ch·ªçn: {session['selected_article'].title[:50]}...\n" +
                    f"‚Ä¢ T·∫°o n·ªôi dung: {len(content)} k√Ω t·ª±\n" +
                    f"‚Ä¢ T·∫°o h√¨nh ·∫£nh: {'C√≥' if image_path else 'Kh√¥ng'}\n" +
                    f"‚Ä¢ Th·ªùi gian: {(datetime.now() - session['start_time']).seconds} gi√¢y",
                    parse_mode='Markdown',
                    disable_web_page_preview=True
                )
                
            else:
                # Fallback to manual posting guide
                await self._handle_publishing_failure(user_id, context, chat_id, content, image_path, progress_message)
                
        except Exception as e:
            logger.error(f"‚ùå Error publishing to Facebook: {e}")
            
            await progress_message.edit_text(
                f"‚ùå **L·ªói ƒëƒÉng Facebook:**\n{str(e)}\n\n" +
                f"üìù **N·ªôi dung ƒë√£ t·∫°o:**\n{content}\n\n" +
                f"B·∫°n c√≥ th·ªÉ copy n·ªôi dung v√† ƒëƒÉng th·ªß c√¥ng.",
                parse_mode='Markdown'
            )

    async def _handle_publishing_failure(self, user_id: int, context: ContextTypes.DEFAULT_TYPE,
                                       chat_id: int, content: str, image_path: str, progress_message):
        """Handle case when Facebook publishing fails"""
        
        session = self.user_sessions[user_id]
        session['state'] = 'failed'
        
        # Create manual posting guide
        keyboard = [
            [InlineKeyboardButton("üìã Copy n·ªôi dung", callback_data=f"copy_content_{user_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await progress_message.edit_text(
            f"‚ö†Ô∏è **Kh√¥ng th·ªÉ ƒëƒÉng t·ª± ƒë·ªông**\n\n" +
            f"üìù **N·ªôi dung ƒë√£ t·∫°o:**\n{content}\n\n" +
            f"üñºÔ∏è **H√¨nh ·∫£nh:** {'C√≥' if image_path else 'Kh√¥ng c√≥'}\n\n" +
            f"üîß **H∆∞·ªõng d·∫´n ƒëƒÉng th·ªß c√¥ng:**\n" +
            f"1. Copy n·ªôi dung ·ªü tr√™n\n" +
            f"2. V√†o Facebook page c·ªßa b·∫°n\n" +
            f"3. T·∫°o b√†i ƒëƒÉng m·ªõi v√† paste n·ªôi dung\n" +
            f"4. Upload h√¨nh ·∫£nh (n·∫øu c√≥)\n" +
            f"5. ƒêƒÉng b√†i",
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
        
        # Send image separately if available
        if image_path and os.path.exists(image_path):
            await context.bot.send_photo(
                chat_id=chat_id,
                photo=open(image_path, 'rb'),
                caption="üñºÔ∏è **H√¨nh ·∫£nh ƒë·ªÉ ƒëƒÉng th·ªß c√¥ng**"
            )

    async def get_workflow_status(self, user_id: int) -> Dict:
        """Get current workflow status for user"""
        if user_id not in self.user_sessions:
            return {'status': 'no_session', 'message': 'Kh√¥ng c√≥ phi√™n l√†m vi·ªác n√†o'}
        
        session = self.user_sessions[user_id]
        state = session.get('state', 'unknown')
        
        status_messages = {
            'fetching_news': 'ƒêang thu th·∫≠p tin t·ª©c...',
            'selecting_article': 'Ch·ªù ch·ªçn b√†i vi·∫øt',
            'checking_expert_facebook': 'ƒêang ki·ªÉm tra Facebook chuy√™n gia...',
            'generating_post': 'ƒêang t·∫°o n·ªôi dung AI...',
            'approving_post': 'Ch·ªù ph√™ duy·ªát n·ªôi dung',
            'editing_post': 'ƒêang ch·ªânh s·ª≠a n·ªôi dung',
            'generating_image': 'ƒêang t·∫°o h√¨nh ·∫£nh...',
            'approving_image': 'Ch·ªù ph√™ duy·ªát h√¨nh ·∫£nh',
            'publishing': 'ƒêang ƒëƒÉng l√™n Facebook...',
            'completed': 'Ho√†n th√†nh',
            'failed': 'Th·∫•t b·∫°i'
        }
        
        return {
            'status': state,
            'message': status_messages.get(state, 'Tr·∫°ng th√°i kh√¥ng x√°c ƒë·ªãnh'),
            'start_time': session.get('start_time'),
            'selected_article': session.get('selected_article', {}).get('title') if session.get('selected_article') else None
        }

    async def handle_post_approval_text(self, user_id: int, action: str, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Handle post approval from text messages"""
        
        if user_id not in self.user_sessions:
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n",
                reply_markup=ReplyKeyboardRemove()
            )
            return
        
        session = self.user_sessions[user_id]
        
        if action == 'approve':
            session['state'] = 'generating_image'
            session['step'] = 'generating_image'
            
            # Send confirmation message
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"‚úÖ **N·ªôi dung ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát**\n\n" +
                     f"{session['generated_post']}\n\n" +
                     "üé® **B∆∞·ªõc 4: T·∫°o h√¨nh ·∫£nh v·ªõi logo PioneerX...**",
                parse_mode='Markdown',
                reply_markup=ReplyKeyboardRemove()
            )
            
            # Continue to image generation
            await self._step4_generate_image(user_id, context, chat_id)
            
        elif action == 'edit':
            session['state'] = 'editing_post'
            session['step'] = 'editing_post'
            
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"‚úèÔ∏è **Ch·∫ø ƒë·ªô ch·ªânh s·ª≠a**\n\n" +
                     f"N·ªôi dung hi·ªán t·∫°i:\n{session['generated_post']}\n\n" +
                     "üí¨ **H√£y g·ª≠i tin nh·∫Øn ƒë·ªÉ ch·ªânh s·ª≠a:**\n" +
                     "V√≠ d·ª•: 'L√†m ng·∫Øn g·ªçn h∆°n' ho·∫∑c 'Th√™m th√¥ng tin v·ªÅ t√°c ƒë·ªông kinh t·∫ø'",
                parse_mode='Markdown',
                reply_markup=ReplyKeyboardRemove()
            )

    async def handle_image_approval_text(self, user_id: int, action: str, context: ContextTypes.DEFAULT_TYPE, chat_id: int):
        """Handle image approval from text messages"""
        
        if user_id not in self.user_sessions:
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n",
                reply_markup=ReplyKeyboardRemove()
            )
            return
        
        session = self.user_sessions[user_id]
        
        if action == 'approve':
            session['state'] = 'publishing'
            session['step'] = 'publishing'
            
            # Send confirmation message
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚úÖ **H√¨nh ·∫£nh ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát**\n\n" +
                     "üì± **B∆∞·ªõc 5: ƒêƒÉng l√™n Facebook...**",
                parse_mode='Markdown',
                reply_markup=ReplyKeyboardRemove()
            )
            
            # Continue to publishing
            await self._step5_publish_to_facebook(user_id, context, chat_id)
            
        elif action == 'regenerate':
            await context.bot.send_message(
                chat_id=chat_id,
                text="üîÑ **ƒêang t·∫°o l·∫°i h√¨nh ·∫£nh...**\n‚è≥ Vui l√≤ng ch·ªù...",
                parse_mode='Markdown',
                reply_markup=ReplyKeyboardRemove()
            )
            
            # Regenerate image
            await self._step4_generate_image(user_id, context, chat_id)

    def _generate_expert_mock_posts(self, selected_article, keywords, config) -> List[Dict]:
        """Generate realistic mock expert Facebook posts"""
        posts = []
        
        # Check if article matches expert's interests
        relevant_topics = {
            'trump': ['Th·ªùi ƒë·∫°i Trump 2.0: Nh·ªØng thay ƒë·ªïi cƒÉn b·∫£n trong ch√≠nh s√°ch kinh t·∫ø M·ªπ', 
                     'Ph√¢n t√≠ch ch√≠nh s√°ch thu·∫ø quan m·ªõi c·ªßa Trump v·ªõi ch√¢u √Å'],
            'trade': ['Cu·ªôc chi·∫øn th∆∞∆°ng m·∫°i m·ªõi: T√°c ƒë·ªông ƒë·∫øn Vi·ªát Nam', 
                     'L√†n s√≥ng b·∫£o h·ªô th∆∞∆°ng m·∫°i: C∆° h·ªôi hay th√°ch th·ª©c?'],
            'economy': ['Kinh t·∫ø to√†n c·∫ßu 2025: Nh·ªØng ƒëi·ªÉm n√≥ng c·∫ßn theo d√µi',
                       'Ph√¢n t√≠ch xu h∆∞·ªõng l·∫°m ph√°t v√† ch√≠nh s√°ch ti·ªÅn t·ªá'],
            'tax': ['C·∫£i c√°ch thu·∫ø doanh nghi·ªáp: B√†i h·ªçc t·ª´ c√°c n∆∞·ªõc ph√°t tri·ªÉn',
                   'Ch√≠nh s√°ch thu·∫ø v√† thu h√∫t FDI: Kinh nghi·ªám qu·ªëc t·∫ø'],
            'china': ['Quan h·ªá M·ªπ-Trung: T√°c ƒë·ªông ƒë·∫øn chu·ªói cung ·ª©ng to√†n c·∫ßu',
                     'Chi·∫øn l∆∞·ª£c kinh t·∫ø c·ªßa Trung Qu·ªëc trong th·ªùi ƒë·∫°i m·ªõi'],
            'business': ['Xu h∆∞·ªõng kinh doanh sau ƒë·∫°i d·ªãch: Nh·ªØng thay ƒë·ªïi c·ªët l√µi',
                        'Chuy·ªÉn ƒë·ªïi s·ªë trong doanh nghi·ªáp: T·ª´ l√Ω thuy·∫øt ƒë·∫øn th·ª±c ti·ªÖn'],
            'market': ['Th·ªã tr∆∞·ªùng ch·ª©ng kho√°n 2025: C∆° h·ªôi ƒë·∫ßu t∆∞ n√†o ƒë√°ng ch√∫ √Ω?',
                      'Ph√¢n t√≠ch chu k·ª≥ th·ªã tr∆∞·ªùng: D·∫•u hi·ªáu nh·∫≠n bi·∫øt ƒë·ªânh v√† ƒë√°y']
        }
        
        # Find relevant posts based on keywords
        found_topics = []
        for keyword in keywords:
            keyword_lower = keyword.lower()
            for topic, posts_list in relevant_topics.items():
                if topic in keyword_lower or keyword_lower in topic:
                    found_topics.extend(posts_list)
        
        # If no specific match, use general business/economy posts
        if not found_topics:
            found_topics = relevant_topics['economy'] + relevant_topics['business']
        
        # Generate 1-3 relevant posts
        num_posts = min(random.randint(1, 3), len(found_topics))
        selected_topics = random.sample(found_topics, num_posts)
        
        for i, topic in enumerate(selected_topics):
            # Generate realistic post data
            post_id = f"pfbid{random.randint(100000, 999999)}ABC{random.randint(100, 999)}"
            days_ago = random.randint(1, 10)
            post_date = datetime.now() - timedelta(days=days_ago)
            
            # Create detailed post content
            post_content = self._generate_expert_post_content(topic, selected_article)
            
            # Generate realistic engagement
            likes = random.randint(50, 500)
            comments_count = random.randint(5, 50)
            shares = random.randint(2, 25)
            
            post = {
                'url': f"{config.EXPERT_FACEBOOK_URL}/posts/{post_id}",
                'post_id': post_id,
                'date': post_date.strftime("%Y-%m-%d"),
                'title': topic,
                'caption': post_content,
                'engagement': {
                    'likes': likes,
                    'comments': comments_count,
                    'shares': shares
                },
                'hashtags': self._generate_relevant_hashtags(selected_article),
                'images': [] if random.random() > 0.3 else [f"image_{random.randint(1, 5)}.jpg"],
                'comments': self._generate_sample_comments(comments_count)
            }
            
            posts.append(post)
        
        return posts
    
    def _generate_expert_post_content(self, topic: str, article) -> str:
        """Generate realistic expert post content"""
        templates = [
            f"""üíº {topic}
            
Sau khi ƒë·ªçc tin t·ª©c m·ªõi nh·∫•t v·ªÅ "{article.title[:50]}...", t√¥i c√≥ m·ªôt s·ªë nh·∫≠n x√©t:

üîç Ph√¢n t√≠ch:
- Xu h∆∞·ªõng n√†y kh√¥ng ph·∫£i ng·∫´u nhi√™n, n√≥ ph·∫£n √°nh nh·ªØng thay ƒë·ªïi c∆° b·∫£n trong c√°ch ti·∫øp c·∫≠n ch√≠nh s√°ch
- T√°c ƒë·ªông ƒë·∫øn Vi·ªát Nam c√≥ th·ªÉ l√† t√≠ch c·ª±c n·∫øu ch√∫ng ta chu·∫©n b·ªã t·ªët chi·∫øn l∆∞·ª£c ·ª©ng ph√≥
- C√°c doanh nghi·ªáp c·∫ßn linh ho·∫°t ƒëi·ªÅu ch·ªânh k·∫ø ho·∫°ch kinh doanh

üí° Khuy·∫øn ngh·ªã:
- Theo d√µi s√°t di·ªÖn bi·∫øn ƒë·ªÉ k·ªãp th·ªùi ƒëi·ªÅu ch·ªânh
- T·∫≠n d·ª•ng c∆° h·ªôi t·ª´ nh·ªØng thay ƒë·ªïi n√†y
- Chu·∫©n b·ªã ph∆∞∆°ng √°n d·ª± ph√≤ng

C√°c b·∫°n nghƒ© sao v·ªÅ v·∫•n ƒë·ªÅ n√†y? üëá""",

            f"""üåê {topic}

Tin t·ª©c v·ªÅ "{article.title[:40]}..." khi·∫øn t√¥i suy ng·∫´m v·ªÅ nh·ªØng thay ƒë·ªïi l·ªõn ƒëang di·ªÖn ra.

üìä M·ªôt s·ªë con s·ªë ƒë√°ng ch√∫ √Ω:
- TƒÉng tr∆∞·ªüng d·ª± ki·∫øn: 15-20%
- T√°c ƒë·ªông ƒë·∫øn GDP: 0.5-1.2%
- Th·ªùi gian ·∫£nh h∆∞·ªüng: 6-12 th√°ng

üéØ ƒêi·ªÅu n√†y c√≥ nghƒ©a g√¨?
‚Üí C∆° h·ªôi m·ªõi cho c√°c doanh nghi·ªáp nh·ªè v√† v·ª´a
‚Üí Th√°ch th·ª©c l·ªõn v·ªõi c√°c ng√†nh truy·ªÅn th·ªëng  
‚Üí C·∫ßn s·ª± ch·ªß ƒë·ªông trong chuy·ªÉn ƒë·ªïi s·ªë

Ai ƒë√£ c√≥ kinh nghi·ªám x·ª≠ l√Ω t√¨nh hu·ªëng t∆∞∆°ng t·ª±? Share ƒë·ªÉ c√πng h·ªçc h·ªèi! ü§ù""",

            f"""üî• {topic}

V·ª´a ƒë·ªçc xong b√†i "{article.title[:45]}..." v√† th·∫≠t s·ª± ·∫•n t∆∞·ª£ng v·ªõi nh·ªØng ph√¢n t√≠ch m·ªõi.

‚ö° Nh·ªØng ƒëi·ªÉm n·ªïi b·∫≠t:
1. Xu h∆∞·ªõng n√†y s·∫Ω ƒë·ªãnh h√¨nh l·∫°i ng√†nh trong 2-3 nƒÉm t·ªõi
2. C√°c c√¥ng ty ti√™n phong s·∫Ω c√≥ l·ª£i th·∫ø c·∫°nh tranh l·ªõn
3. R·ªßi ro ch√≠nh l√† s·ª± ch·∫≠m tr·ªÖ trong vi·ªác th√≠ch ·ª©ng

üöÄ C∆° h·ªôi cho Vi·ªát Nam:
- V·ªã tr√≠ ƒë·ªãa l√Ω thu·∫≠n l·ª£i
- Chi ph√≠ nh√¢n c√¥ng c·∫°nh tranh  
- Ch√≠nh s√°ch khuy·∫øn kh√≠ch t·ª´ ch√≠nh ph·ªß

Theo c√°c b·∫°n, doanh nghi·ªáp Vi·ªát Nam c·∫ßn l√†m g√¨ ƒë·ªÉ t·∫≠n d·ª•ng c∆° h·ªôi n√†y? üí≠"""
        ]
        
        return random.choice(templates)
    
    def _generate_relevant_hashtags(self, article) -> List[str]:
        """Generate relevant hashtags based on article content"""
        base_hashtags = ['#KinhTe', '#PhanTich', '#ChuyenGia', '#Business']
        
        # Add topic-specific hashtags
        title_lower = article.title.lower()
        if 'trump' in title_lower:
            base_hashtags.extend(['#Trump', '#ChinhSach', '#MyQuoc'])
        if 'trade' in title_lower or 'th∆∞∆°ng m·∫°i' in title_lower:
            base_hashtags.extend(['#ThuongMai', '#XuatNhapKhau', '#QuocTe'])
        if 'economy' in title_lower or 'kinh t·∫ø' in title_lower:
            base_hashtags.extend(['#KinhTeVietNam', '#TangTruong', '#DauTu'])
        if 'market' in title_lower:
            base_hashtags.extend(['#ThiTruong', '#ChungKhoan', '#TaiChinh'])
        
        return base_hashtags[:6]  # Limit to 6 hashtags
    
    def _generate_sample_comments(self, count: int) -> List[str]:
        """Generate realistic sample comments"""
        comment_templates = [
            "Ph√¢n t√≠ch r·∫•t hay anh ∆°i! üëç",
            "C·∫£m ∆°n anh ƒë√£ chia s·∫ª nh·ªØng g√≥c nh√¨n s√¢u s·∫Øc",
            "Theo em nghƒ© th√¨ xu h∆∞·ªõng n√†y s·∫Ω c√≤n ti·∫øp t·ª•c",
            "R·∫•t b·ªï √≠ch! Cho em h·ªèi v·ªÅ...",
            "ƒê·ªìng √Ω v·ªõi quan ƒëi·ªÉm c·ªßa anh",
            "Thanks for sharing! Very insightful analysis",
            "Ch·ªù b√†i ph√¢n t√≠ch ti·∫øp theo c·ªßa anh üî•",
            "Hay qu√°! Share cho b·∫°n b√® ƒë·ªçc th√™m",
            "Anh c√≥ th·ªÉ vi·∫øt chi ti·∫øt h∆°n v·ªÅ ph·∫ßn n√†y kh√¥ng?",
            "Perspective r·∫•t th√∫ v·ªã, ch∆∞a t·ª´ng nghƒ© ƒë·∫øn"
        ]
        
        return random.sample(comment_templates, min(count, len(comment_templates)))
